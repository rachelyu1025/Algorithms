// [PGS] 성격 유형 검사하기, +3
// 소요시간 : 엄청나게 오래걸림 ^^;

// 테스트 1 〉	통과 (0.11ms, 33.6MB)
// 테스트 2 〉	통과 (0.11ms, 33.4MB)
// 테스트 3 〉	통과 (0.11ms, 33.5MB)
// 테스트 4 〉	통과 (0.11ms, 33.4MB)
// 테스트 5 〉	통과 (0.11ms, 33.4MB)
// 테스트 6 〉	통과 (0.11ms, 33.5MB)
// 테스트 7 〉	통과 (0.22ms, 33.6MB)
// 테스트 8 〉	통과 (0.22ms, 33.5MB)
// 테스트 9 〉	통과 (0.22ms, 33.6MB)
// 테스트 10 〉	통과 (0.23ms, 33.5MB)
// 테스트 11 〉	통과 (0.24ms, 33.5MB)
// 테스트 12 〉	통과 (0.26ms, 33.5MB)
// 테스트 13 〉	통과 (0.28ms, 33.5MB)
// 테스트 14 〉	통과 (0.36ms, 33.5MB)
// 테스트 15 〉	통과 (0.35ms, 33.5MB)
// 테스트 16 〉	통과 (0.54ms, 33.5MB)
// 테스트 17 〉	통과 (0.39ms, 33.6MB)
// 테스트 18 〉	통과 (0.35ms, 33.5MB)
// 테스트 19 〉	통과 (0.34ms, 33.5MB)
// 테스트 20 〉	통과 (0.36ms, 33.6MB)

function solution(survey, choices) {
  const type = ['RT','CF','JM','AN'];
  let result = '';
  
  let score = { // 모든 유형의 점수를 확인하기 위해  객체 생성 
      'A': 0,
      'C': 0,
      'F': 0,
      'J': 0,
      'N': 0,
      'M': 0,
      'R': 0,
      'T': 0,
  }
  
  // 7가지의 문항 중 0점인 4번을 기준으로 점수계산 (양수,음수를 기준으로 타입 나눌 계획)
  let getScore = choices.map(el => 4 - el); 


  for(let i = 0; i < survey.length; i++){ // 입력받은 배열의 요소를 순차적으로 돌며 점수비교 
      if(getScore[i] >= 0){ // getScore[i](=survey[i])의 점수가 0이상(양수)이면 두 문자로 이루어진 survey의 요소 중 앞의 문자를 선택 
          score[survey[i][0]] += getScore[i]; // 생성해둔 객체 내 선택된 문자의 값에 점수를 더해줌
      }else {
          score[survey[i][1]] += Math.abs(getScore[i]); //생성해둔 객체 내 선택된 문자의 값에 점수를 더해주는데, getScore가 음수이므로 Math.abs메서드를 이용하여 절대값으로 변경 후 더해줌! 
      }
  }
  
  type.map(el => { // 4가지의 지표를 순환하여 각 지표마다 두 문자로 이루어진 문자열의 각 문자의 점수를 객체에 접근해 비교하여 
      if(score[el[0]] > score[el[1]]) result += el[0]; // 앞의 문자 점수가 더 크면 결과 변수에 앞 문자를 더해준다.
      else if(score[el[0]] < score[el[1]])result += el[1]; //뒤의 문자 점수가 더 크면 결과 변수에 뒤의 문자를 더해준다.
      else result += el[0]; // 점수가 같으면 사전순으로 빠른 앞 문자를 더해준다. 
  })
  
  return result;
}

