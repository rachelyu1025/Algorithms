//[PGS] 최솟값 만들기, +3

// 테스트 1 〉	통과 (0.08ms, 33.6MB)
// 테스트 2 〉	통과 (0.20ms, 33.6MB)
// 테스트 3 〉	통과 (0.17ms, 33.6MB)
// 테스트 4 〉	통과 (0.20ms, 33.6MB)
// 테스트 5 〉	통과 (0.19ms, 33.6MB)
// 테스트 6 〉	통과 (0.17ms, 33.6MB)
// 테스트 7 〉	통과 (0.17ms, 33.5MB)
// 테스트 8 〉	통과 (0.18ms, 33.5MB)
// 테스트 9 〉	통과 (0.17ms, 33.5MB)
// 테스트 10 〉	통과 (0.18ms, 33.5MB)
// 테스트 11 〉	통과 (0.22ms, 33.6MB)
// 테스트 12 〉	통과 (0.14ms, 33.5MB)
// 테스트 13 〉	통과 (0.15ms, 33.5MB)
// 테스트 14 〉	통과 (0.16ms, 33.5MB)
// 테스트 15 〉	통과 (0.16ms, 33.5MB)
// 테스트 16 〉	통과 (0.15ms, 33.5MB)
// 효율성  테스트
// 테스트 1 〉	통과 (0.70ms, 33MB)
// 테스트 2 〉	통과 (0.79ms, 33.1MB)
// 테스트 3 〉	통과 (0.68ms, 33.5MB)
// 테스트 4 〉	통과 (0.75ms, 33.1MB)

// 배열 하나는 오름차순, 다른 하나는 내림차순 정렬을 하여
// 가장 작은 수와 가장 큰 수의 곱으로 최소합을 구한다! 
function solution(A,B){
  A.sort((a,b) => a - b);
  B.sort((a,b) => b - a);
  
  return A.reduce((acc,curr,i) => {
      let temp = curr * B[i];
      return acc+temp;
  },0)
}

